**Namespace** provides _"spaces"_ for "names". They provide a context for looking up the value of an object associated with a name.

Namespaces makes your packages **self-contained** in two ways:
* The **imports**: defines how a function in one package finds a function in another.
* The **exports**: specifise which functions are available _outside_ of your package. Internal functions are available only _within_ your package and _can not_ easily be used by another package.

# Search path

When you call a function, R looking in the following environments sequencely:
1. global environment.
2. search path: the list of all the packages you have **attached**. You can check your _search path_ with `search()`.

Difference between **loading** and **attaching** pachages:
1. If a package is installed:
    * **loading** will load code, data and any DLLs; register S3 and S4 methods; and run the `.onLoad()` function.
        * The package is available in memory.
        * The package is **not** in the _search space_.
        * You **can not** access its components without using `::`. Because `::` will load the package by default if it is not loaded.
        * `requireNamespace()` or `loadNamespace()`: loading package.
    * **Attaching** puts the package in the _search path_.
        * You **can not** attach a package withour _loading_ it.
        * `library()` and `require()`: loading and attaching package.

2. If a package isn't installed. Loading (and hence attaching) will fail with an error.

There are four functions for _loading_ and _attaching_: `loadNamespace("x")`, `requireNamespace("x", quietly = TRUE)`, `library(x)`, and `require(x, quietly = TRUE)`. Only `library` and `requireNamespace` could be used in practice.

* Using `library(x)` in data analysis scripts. **Never** use it in package, instead, use `Imports` and `Depends`.
* Using `requireNamespace(x, quitely = TRUE)` inside a package if you want a _specific action_(e.g. throw an error) depending on whether or not a suggestion package is installed.

Difference between `Imports` and `Depends`.
* `Imports` just _loads_ the package.
* `Depends` _attaches_ it.

**Suggestion**: Unless there is a good reason otherwise, you should always list packages in `Imports` not `Depends`.

# The NAMESPACE

In `NAMESPACE` file:
* each line contains a **directive**: `S3method()`, `export()`, `exportClass()`...
* each directive describes
    * export:
        1. `export()`: export functions (including S3 and S4 generics).
        2. `exportPattern()`: export all functions that match a pattern.
        3. `eportClass()`, `exportMethods()`: export S4 classes and methods.
        4. `S3method()`: export S3 methods.
    * import:
        1. `import()`: import all functions from a package.
        2. `importFrom()`: import selected functions (including S4 generics).
        3. `importClassFrom()`, `importMethodsFrom()`: import S4 classes and methods.
        4. `useDynLib()`: import a function from **C**.

# Workflow

1. Add roxygen comments to `.R` files.
2. Run `devtools::document()` or press`Ctrl + Shift + D` in Rstudio to convert roxygen comments to `Rd` files.
3. Look at `NAMESPACE` and run tests to check that the specification is correct.
4. Rinse and repeat until the correct functions are exported.

# Exports

* When you create a new package with `devtools::create()`, it produces a **temporary** `NAMESPACE` that exports **everything** in your package that doesn't start with `.`.
* If you are just working **locally**, it's fine to export everything.
* If you'd like to share package with others, it's better to export needed functions. It **reduces conflicts** with other packages.

* Export functions must be **documented**, because others will use it.

* It's better to export **too little** than **too much**.

* Packages that have a wide audience should strive to do **one** thing and do it well. Any functions not related to that purpose should **not** be exported.

* Create a `utils.R` file contains many small functions that are useful within package but **not export** them. 

## S3

Four scenarios for S3 methods:

1. A method for an **exported** generic: export every method.

2. A method for an **internal** generic: It is better to **exporting every S3 method** you write because it's simpler and makes it less likely that you'll introduce hard to find bugs. `devtools::missing_s3()` could be used to list all S3 methods that you've forgotten to export.

3. A method for a generic in a **required package**. you need to **import** the generic and **export** it.

4. A method for a generic in a **suggested package**. Namespace directives can **not** reference suggested packages. Design your package **dependencies** in a way to avoids this scenario.

## S4

* **S4 classes**
    * If you want others to be able to **extend your class**, `@export` it.
    * If you want others to **create instances** of your class but not to extend it, `@export` the **constructor function**, not the class.

* **S4 generics**: `@export` if you want the generic to be **publicly usable**.

* **S4 methods**: only need to `@export` methods **for generics** that you did **not** define. It's _recommend_ to `@export` **every** method so that you don't need to remenber whether or not you create the generic.

## RC
Similar to **S4**.

## Data
files that in `data/` **don't** use the usual namespace emchanism and **don't** need to be export.

# Imports

* `NAMESPACE` controls which external functions can be used by your package _without_ having to use `::`.

* **Difference** between `Import` field in `NAMESPACE` and `DESCRIPTION`:
    * In `NAMESPACE`: do **nothing** to functions. It just makes sure that package is installed when your package is.
    * `Depends`: 
        * If your package is **attached**, it also **attaches** all packages listed in `Depends`.
        * If your package is **loaded**, packages in `Depends` are **loaded**, but not attached. You need to qualify function names with `::` or specifically import them.
    * In `DESRIPTION`:
        List the package in `DESCRIPTION` so that it's **installed**, then always **refer** to it with `pkg::fun()`. It makes your code a lot easier to read when you come back to it in the future.
    * Every package mentioned in `NAMESPACE` must also **be present** in the `Imports` or `Depends` fields.

## R functions
* If you are using just **few** functions from another package. Note the package name in the `Imports:` field of the `DEXCRIPTION` file and call the functions explicitly using `::`.
    
* If you are using functions **repeatedly**, you can avoid `::` by importing the function with `@importFrom pkg fun`.

* **Least recommend** because of unreadable code and easier conflict of function names: if you are repeatedly using **many** functions from another package, you can import all of them using `@import package`.

## S3

The same rules as function.

## S4
* When importing:
    * **classes**: `@importClassesFrom package ClassA ClassB ...`
    * **generic**: `@importMethodsFrom package GenericA GenericB ...`

* Explicit in:
    * `Impors: methods` in `DESCRIPTION`
    * Or in the `package docs`:

    ```
    #' @import methods
    NULL

    #' @importFrom methods setClass setGeneric serMethod setRefClass
    NULL
    ```

