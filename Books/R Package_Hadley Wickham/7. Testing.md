# Workflow

* **Without testing**:
    1. Write a function.
    2. Load it with `Ctrl + Shift + L` or `devtools::load_all()`.
    3. Experiment with it in the console to see if it works.
    4. Rinse and repeat.

* **Automated testing**:
    * Benefits:
        1. **Fewer bugs**: because you describe the behaviour of your code in **two places**, your cor and your test, you are able to check one against the other.
        2. **Better code structure**: because writting tests forces you to **break up** complicated parts of your code.
        3. **Easier restarts**: your tests will let you know what to do next, if you always finish a coding session by creating a failing test.
        4. **Robust code**: If all the major functionality of your package has an associated test, you can confidently make big changes **without worrying about accidentally breaking something**.

# Test workflow

1. Using `devtool::use_testthat()` to:
    1. Create a `tests/testthat` directory.
    2. Adds testthat to the `Suggests` field in the `DESCRIPTION`.
    3. Creates a file `tests/testthat.R` that runs all your tests when `R CMD check` runs.

2. Common workflow:
    1. modify your code or tests.
    2. Test your package with `Ctrl + Shift + T` or `devtools::test()`
    3. Repeat until all tests pass.

# Test structure

* A test file **lives** in `test/testthat/` folder. It's name must start with `test`.
* Tests are organised hierarchically: `expectations` are grouped into `tests` which are organised in `files`:
    * `expectation`: dedscribes the expected **result** of a computation.
    * `test` groups: together **multiple expectations** to test the output from a simple function, a range of **possibilities** for a single parameter from a more complicateed function, or tightly related functionality from across **ultiple functions**.
    * `file` groups: together **multiple related tests**. Files are given a **human readable name** with `context()`.

## Expectations
* It makes a **binary assertion** about whether or not a function call does what you expect.
* structure:
    * Start with `expect_`.
    * Two arguments:
        1. Actual result.
        2. Result you expect.
    * Error: if the actual and expected results don't agree.
* Most important expectations (from totally 20 in `testthat` package)
    1. **equality**: 
        * `expect_equal()`: for equality within a **numerical tolerance**
        * `expect_identical()`: for **exact** equivalence.
    2. **Match a character vector against a regular expression**: `expect_match`. Options:
        * `all`: whether all elements or just one element needs to match.
        * `ignore.case = FALSE`: whether ignore cases.
        * `fixed = TRUE`
    3. **Check the printed output**: `expect_output()`
    4. **Check the message**: `expect_message()`
    5. **Check the warning**: `expect_warning()`
    6. **Check the error**: `expect_error()`
    * Note: you can leave the 2nd argument **blank** tosee if message, warning, error is created.
    7. Check an object `inherit()`s from a specified **class**: `expect_is`
    8. `expect_true()` and `expect_false()` are useful catchalls if **none** of other expectations do what you need.
    9. Check that the result is the **same as the last time**: 
        1. `expect_equal_to_reference()` caches the result the first time its run.
        2. Compares it to subsequent runs.
        3. If some reason the result **does** change, just **delete** the cache (*) file and re-test.

# Writting tests
* Each test should have an **informative** name and a **single** unit of functionality.
* Create a new test using `test_that()` with _test name_ and _code block_ as arguments.
    * _test name_ should complete sentence "Test that..."
    * _code block_ should be a collection of _expectations_.
* the test should be **informative**
* **Avoid** putting too many expectations in one test.

# What to test

Whenever you are tempted to type something into a print statement or a debugger exression, whrite it as a test instead.

* Focus on testing the **external interface** to your function.

* Strive to test each behaviour in **one and only one** test.

* Avoid testing simple code that you're confident will work.

* Always write a test when you discover bug.

# Test files

* Each file should contain a **single** `context()` call that provides a brief description of its contents.
* To have one file of tests for each complicated function.