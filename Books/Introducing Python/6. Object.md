---
title: "6. Object"
author: Shuyu
date: 3rd. Oct. 2018
output:
    word_document:
        path: C:/Users/zsy/Documents/google_drive/Notes/programming/6. object.docx
---

* An object contains:
    * data: variables, called **attributes**
    * code: functions, called **method**
* When you create new objects no one has ever created before, you must create a **class** that indicates what they contain.

# 1. Define a class
* An empty class:

    ```
    class class_name():
        pass

    ```
* For _function_ and _class_ we use the **pass** to indicate they are empty

    ```
    class class_name():
        def __init__(self, name):
        self.name = name
    ```
* \__init__(): It's used to do anything that's needed to **distinguish** this object from others created from the _same_ class.
* The **self** argument specifies that it refer to the individual object itself.

# 2. Inheritance
* **inheritance**: creating a new class from an **existing class** but with some additions or changes. 
* You can add method by _def_ them in the block
* If the added method already existed in the class, your change will _overrides_ the behavior of the old class.
* The **original** class is called: _parent, superclass, base class_.
* The **new** class is called: _child, subclass, derived class_.

    ```
    class new_class(old_class):
        pass

    ```
* You can call the functions of _superclass_ in _subclass_ (which has been overrode) by **super().parent_method()**
```
class sub_class(super_class):
    def method():
        super.parent_method()
```
* Using **super()** to define method in child class allows it **update** all changes in parent class automatically.

# 3. In **self** defense
* For Python **self** is needed as the first argument to **instance methods**.
* What does Python do when we call a _method_ for an _object_?
    
    ```
    class class():
        def method(self, *args):
            operation
    
    object = class()
    object.method()
    ```

    1. Look up the _class_ of the _object_.
    2. pass the _object_ to the _method_ of the _class_ as the **self** parameter.

# 4. Get and Set attribute values with Properties
* In Python all attributes and methods are **public** (in some object-oriented languages support _private_ object attributes). It means you can access to attributes directly in Python.

* For setting and accessing _private methods_, _getter_ and _setter_ also work in Python, but to be Pythonic **properties** is recommended.
* Define **property**:
    * method = property(_getter_, _setter_)
    * Decorator: Put **decorators** before the methods
        * `@property` goes before the getter method
        * `@name.setter` gose before the setter method.

* **Advantage** of using a _property_ instead of direct attribute access: If you change the definition of the attribute, you only need to fic the code within the class definition, not in all the callers.

# 5. Name Mangling for Python
* Python has a naming convention for attributes that **should not be visible outside** of their class definition: begin by using with **two underscores**(__).

* Notes:
    * The naming convention doesn't make it private, Python just _mangle_ the name to make it unlikely for external code to stumble up on it.
    * It means you **can** call it but in a different name: object._class__method().
    * It's not a perfect protection, but name mangling discourages accidental or intentional direct access to the attribute.

# 6. Method Types
1. **Instance method**: 
    * methods with an initial **self** within a class definition.
    * Its first argument is **self** that will be passed **object** when it was called.
    ```
    def class_name():
        method(self):
            _operation_
    
    # calling 
    object = class_name()
    object.method()
    ```

2. **Class method**: 
    * methods that affect the class as a **whole**. 
    * It is defined with a preceding **@classmethod** decorator.
    * Its first argument is **class** indicating the **whole class**.
    * In Python tradition, the parameter "class" is called **cls**, because "class" is a reserved word.
    * When calling the class method, *class_name.method()* should be used, **not** *object.method()*
    ```
    def class_name():
        @classmethod
        def method(cls):
            _operation_
    
    # calling
    class_name.method()
    ```

3. **Static method**:
    * methods that affect **neither** the class **nor** it's objects.
    * It's just in there for **convenience** instead of floating around on its own.
    * It is preceded by a **@staticmethod** decorator.
    * You **don't** need to create an object from this class to access the static methods.

    ```
    def class_name():
        @staticmethod
        def method():
            operation
    
# 7. Duck typing

* Python has a **loss** implementation of _polymorphism_. 
* _Traditional polymorphism in object-oriented languages_: Different classes can define _different_ behaviors to the method with the _same_ name.
* _Python specific polymorphism_: When calling object.method(), it can be used on _any_ object with the _method_ definition in their classes, **respectively**. (different behavior with the same _method_)

# 8. Special Methods (Magic Methods)

* The names of these methods begin and end with **double underscores**(__)
* The list of _special methods_:

    names|symbols
    ---|---
    `__init__(self, _args_)` | class_name(_args_)
    **Comparison** |
    `__eq__(self, other)` | self == other
    `__ne__(self, other)` | self != other
    `__lt__(self, other)` | self < other
    `__gt__(self, other)` | self > other
    `__le__(self, other)` | self <= other
    `__ge__(self, other)` | self >= other
    **Math** |
    `__add__(self, other)` | self + other
    `__sub__(self, other)` | self - other
    `__mul__(self, other)` | self * other
    `__floordiv__(self, other)` | self // other
    `__truediv__(self, other)` | self / other
    `__mod__(self, other)` | self % other
    `__pow__(self, other)` | self ** other
    **Miscellaneous** |
    `__str__(self)` | str(self)
    `__repr__(self)` | repr(self)
    `__len__(self)` | len(self)

* You can specifically **define** the behavior of these _special methods_ by using `__names__` in different class and **call** them by `_symbols_`.
* For more information: [Python document](https://docs.python.org/3/reference/datamodel.html#special-method-names)

# 9. Composition

* **Composition** or **aggregation** means _x has a y_ or _y is a part of x_. (duck has a tail)
* **Inheritance** means _child is a parent_. (duck is a bird)
* In practice, it means the _method_ in the _new class_ will call the method of other classes to achieve something. (The _y_'s method is a part of _x_'s)

# 10. When to use Classes and Objects versus Modules

* Objects: You need a number of **individual instances** that have **similar behavior (methods)**, but **differ** in their internal states (attributes).

* Classes: Support **inheritance**, modules don't.

* Module: If you want **only one** of something, a module might be best. No matter how many times a Python modules is referenced in a program, **only one copy** is loaded.

* Classes: If you have **a number of variables** that contain **multiple values** and can be passed as arguments to **multiple functions**.

* **Avoid overengineering datastructures**: Use the **simplest** solution to the problem. _dictionary, list, tuple_ --simpler--> _module_ --simpler--> _class_

# 11. Named tuples (in Module "collections")

* A **named tuple** is a subclass of tuples with which you can _access values by name (`.name`) as well as by position (`[offset]`)

* Create _namedtuple_
    * Call **namedtuple** function by 2 arguments:
        * The name
        * A string of the field names, separated by **spaces**
        ```
        from collections import namedtuple
        tuple = namedtuple('name', 'field_name1 field_name2')
        one_tuple = name('field_value1', 'field_value2')
        ```

    * From a _dictionary_

        ```
        tuple = namedtuple('name', 'field_name1, field_name2')
        dictionary = ('names': 'field_name1', 'field_name2')        
        n_tuple = name(**dictionary)
        ```
        * **dictionary is a _keyword argument_, remember?


* Change the items: Namedtuple is an **immutable** object. 
    * We could **not** use `one_tuple.field = value` to change the value of a namedtuple.
    * Tricks can be used:
        * `.replace()`: new_tuple = old_tuple.replace(field1 = new_value1, field2 = new_value2)
        * Change in _dictionary_ and then namedtuple:
            1. Define the tuple as a dictionary: `Namedtuple = {field1, field2}`
            2. Do something on dictionary: `Namedtuple['field3'] = value3`
            3. Convert it back into namedtuple.
                
* Advantages of namedtuple:
    * It looks and acts like a **immutable object**
    * It is more **space- and time-efficient** than object
    * You can access attributes by using _.notation_ instead of _dictionary-style square bracket_
    * You can use it as a dictionary key.