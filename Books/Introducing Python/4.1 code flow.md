---
title: '4.1 code flow'
author: Shuyu
date: 30th. Sept. 2018
output: 
    word_document:
        path: C:\Users\zsy\Documents\google_drive\Notes\programming\4.1 code flow.docx
---

* Python uses the **white space (or indentation)** rather than parentheses to define program structure.
* the recommend code style is _PEP-8_.
* don't use tabs or mix tabs and spaces.

syntax | describe
--- | ---
`#` | comment
`\` | continue lines
`;\` |continue to add a new line

## 1.1 Code structure

### 1. if statement

1. Two options for condition.

    ```
    if _condition_ :
        _operation for True_
    else: 
        _operation for False_
    ```
2. Multiple options:

    ```
    if _condition_ == _option1_ :
        _operation1_
    elif _condition_ == _option2_:
        _operation2_
    elif _condition_ == _option3_:
        _operation3_
    else _condition_ == _last option_:
        _last operation_
    ```

3. comparison operators:

    operators | describe
    ---|---
    `==` | equality
    `!=` | inequality
    `<` | less than
    `<=` | less than or equal 
    `>` | greater than 
    `>=` | greater than or equal
    `in` | membership
    `and`, `or`, `not` | boolean operators

In Python, a false value doesn't necessary need to explicitly _False_, following values are all considered as _False_, any thing else is considered as _true_

boolean | null | zero integer | zero float | empty string | empty list | empty tuple | empty dictionary | empty set
---|---|---|---|---|---|---|---|---
False | None | 0 | 0.0 | '' | [] | () | {} | set()

### 2. Repeat with _while_

1. basic structure: if _condition_ == True, then continue the loop.

```
while _condition_ :
    _operation1_
    _operation2_
```

2. infinite loop ('while True') and **break** statement

```
while True:
    _operation_
    if _condition_:
        break
```
3. skip one loop with **continue**

4. Check break use with **else**: If the loop ended normally (no break call), control passes to an optional **else**. _It is very useful to check whether the previous loop ran to completion.

```
while _condition1:
    _operation1_
    if _condition2_:
        break
else: # break not called
    _operation2_
```
### 3. **Iterate** with _for_

* The advantages of iterator:

    * to traverse data structures without knowing how large they are or how they are implemented.
    * you can iterate over data that is created **on the fly**, allowing processing of data _streams_ that would other wise not fit in the computer's memory all at once.
    * **iterable** objects: _lists_, _strings_, _tuples_, _dictionaries_, _sets_
    * for iterating over _dictionaries_
        * _for index in dictionary_ or _for _dictionary.keys()_ : computer will iterates over _keys_;
        * _for index in dictionary.values()_ : iterating over _values_;
        * _for index in dictionary.items()_: iterating over _items_ and returning _tuples_ containing _(key, value)_ 
        * _for index1, index2 in dictionary.items()_: iterating over items and returning _index1_ = _key_ and _index2_ = value.

* Basic structure:

```
for _index_ in _iterable objects_:
    _operation_
```

* Controlling stream with _break_, _continue_, _else_.

### 4. zip(), range()

* `zip(_seq1_, _seq2_, _seq3_)`: iterate multiple sequences.

* `range(start, end, step)`: generate a sequence of number. the _start_, _end_, _step_ are similarly used in _slices (list[start:end:step])_. **The last value created will be just before _end_. It means you _ends_ = 1 + _last value you want_.**

* Like _zip()_, _range()_ returns an **iterable object**, so you need to step through the values with _for in_, or convert them to sequences like _lists_, _dictionaries_ ...

```
for index in zip(_seq1_, _seq2_, _seq3_)
    _operation_

list(zip(_seq1_, _seq2_, _seq3_))

dict(zip(_seq1_, _seq2_, _seq3_))
```

