---
title: "7. Mangle data like a pro"
author: Shuyu
date: 7th October 2018
output:
    word_document:
        path: C:/Users/zsy/Documents/google_drive/Notes/7. Mangle data like a pro.docx
---

# Build-in Python datatype
* **strings**: sequences of _Unicode_ characters, used for text data.
* **bytes and bytearrays**: Sequences of _8-bit integers_, used for binary data.

# 1. Text strings

# 1.1 Unicode

* **ASCII**: 
    * Stores letters in _byte_ (8-bits). 
    * Actually it only used 7 bits(128 unique values):
        * 26 uppercase letters
        * 26 lowercase letters
        * 10 digits
        * some punctuation symbols
        * some spacing characters
        * and some nonprinting control codes.  

* 8-bits code system:
    * Latin-1, or ISO 8859-1
    * Windows code page 1252

* **Unicode**:[Unicode Code Chart page](http://www.unicode.org/charts/) 
    * It's an **international standard** to define the characters of **all** the world's languages, plus symbols from mathematics and other fields.
    * The characters are divided into eight-bit sets called **planes**. 
    * The first 256 planes are the **basic multilingual planes**

# 1.2 Python 3 Unicode strings

* Python 3 strings are Unicode strings, *not* byte arrays(which is used in Python 2).
* Directly using Unicode ID or name for a character in a Python string:
    * \u + 4 hex character (2 _plane number (00 to FF)_ + 2 _index number(00 to FF)_)
    * The first plane (00) is olg ASCII and the chatacterpositions within that plane are the same as ASCII.
    * \U + 8 hex characters (notes: here is uppercase "U") to handle these cases, and letfmost ones need to be 0.
    * \N{name} : specify it by its standard _name_

* Python **unicodedata** module: search Unicode with name, and vice versa.

    Functions |                          descriptions
    --------- | ---------------------------------------------------------------
    lookup()  | Takes a _case-insensitive_ name and returns a Unicode character
    name()    | Takes a Unicode character and returns an *uppercase name*

* The names from `.lookup()` should be modified before used in Python code: 
    1. exchange the positions of the contents before and after _comma_.
    2. remove _comma_

# 1.3 Encode and decode with UTF-8
* The UTF-8 dynamic encoding scheme:
    * One byte for ASCII
    * Two bytes for most Latin-derived (but not Cyrillic) languages
    * Three bytes for the rest of the basic multilingual plane
    * Four bytes for the rest, including some Asian languages and symbols

* UTF-8 is the standard text encoding in Python, Linux and HTML

## Encoding 

* `encode(encoding_name, handle)`: convert strings into selected encoding pattern.
    * optional *encoding_names*
        
             names      |                    descriptions
        --------------- | ---------------------------------------------------
        'ascii'         | Good old seven-bit ASCII
        'utf-8'         | Eight-bit variable-length encoding
        'latin-1'       | Also known as ISO-8859-1
        'cp-1252'       | A common Windows encoding
        'unicode-escape | Python Unicode literal format, \uxxxx or \Uxxxxxxxx

    * optional _handle_: chose the way to handle the cases that requirement is not in the encoding system

              options       |                                  descriptions
        ------------------- | ------------------------------------------------------------------------------
        'strict'            | return error message
        'ignore'            | return an empty string ''
        'replace'           | return a question symbol ('?')
        'backslashreplace'  | return a string with \ before a Python Unicode character string (i.g. \\u2603)
        'xmlcharrefreplace' | return an entity strings that you can use in web pages (i.g. &#9731)

## Decoding
* `decode(encoding_name)`: convert bytes to string.

# 1.4 For more ingormation
* [Unicode HOWTO](https://docs.python.org/3/howto/unicode.html)
* [Pragmatic Unicode](https://nedbatchelder.com/text/unipain.html)
* [The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/)

# 2. Format
For **interpolating** data values into strings, Python provides two style: _old style_, _new style_. Both styles are supported in Python 2 and 3.
## 1.1 Old style with %
* The old style of string formatting has the form **string % data** (i.g. `'We got %d%% agreement from the board.' % 100`)

symbols |         descriptions
------- | ----------------------------
%s      | string
%d      | decimal integer
%x      | hex integer
%o      | octal integer
%f      | decimal float
%e      | exponential float
%g      | decimal ar exponential float
%%      | a literal %

* Type other values between the % and the type specifier to designate **minimum and maximum width**.

symbols |                                                    description                                                     |              example
------- | ------------------------------------------------------------------------------------------------------------------ | ----------------------------------
%n      | The **minimum field width** of each value is _n_ characters.                                                       | `'%10d %10f %10s' % (n, f, s)`
%-      | align the values to the right.                                                                                     | `'%-10d %-10f %-10s' % (n, f, s)`
%.m     | The **maximum character width** is _m_ characters. For %d it constrains it with only _m_ digits after the decimal. | `%.4d %.4f %.4s % (n, f, s)`
%*.*    | get the field width from arguments.                                                                                | `%10.4d %10.4f %10.8s % (n, f, s)`

## 1.2 New style with {} and format

* The new style of string formatting has the form __'string {}'.format(data)__. (i.g.`'we got {} agreement from the board.'.format('100%')`)
* You don't need to make sure the order of items in 'data' consist with the position they'd like to be interpolated. Typing _offsets_ in the '{}' can match the items of 'data' to '{}'. (i.g. '{2} {0} {1}'.format(f, n, s))
* You can set _data_ as: list, dictionary or named arguments. 

    ```
    d = {'n':42, 'f':7.03, 's':'string cheese'}
    '{0[f]} {0[f]} {0[s]} {1}'.format(d, 'other')
    ```
* Use ':' just like '%' in old style to specify the type of interpolated values. (i.g. `'{n:d} {f:f} {s:s}'.format(n=42, f=7.03, s='string cheese')`)
* The format setting:

    symbols |                                                                                 description                                                                                  |                       example
    ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------
    `:n`    | The **minimum** field width of each value is _n_ characters.                                                                                                                 | `'{0:10d} {1:10f} {2:10s}'.format(n, f, s)`
    `>`     | Right alignment                                                                                                                                                              | `'{0:>10d} {1:>10f} {2:>10s}'.format(n, f, s)`
    `<`     | left alignment                                                                                                                                                               | `'{0:<10d} {1:<10f} {2:<10s}'.format(n, f, s)`
    `^`     | centered                                                                                                                                                                     | `'{0:^10d} {1:^10f} {2:^10s}'.format(n, f, s)`
    `n.m`   | Constrain the maximum character with for string and the number of digits after decimal for float. **Note**: It **doesn't** work for integer (it is different from old style) | `'{0:^10.4d} {1:^10.4f} {2:^10.4s}'.format(n, f, s)`

* **Fill character**: If you want something **other than spaces** to pad your output file, put it after the : and before any alignment(<,>,^) or width specifiers. (i.g. `'{0:!^20s}'.format('stings')` $\rightarrow$ `'!!!!!!BIG SALE!!!!!!'`)

# 2. Match with Regular expression

## 2.1 Basic functions
* The functions are in a standard module **re**, remember to _import_ it before using.

             functions              |                                      descriptions
----------------------------------- | ---------------------------------------------------------------------------------------
`re.match(pattern, source)`         | Check the _source_ **begin** with the _pattern_
`re.compile(pattern)`               | Compile _pattern_ before using `.match()` could speed up it.
`search()`                          | returns the **first match**.
`findall()`                         | returns a list of **all non-overlapping** matches.
`split()`                           | split _source_ **at matches** with _pattern_ and returns a _list_ of the string pieces.
`sub(pattern, source, replacement)` | **changes all** parts of _source_ that are matched by _pattern_ to _replacement_

## 2.2 Patterns: Regular expression

1. Basic:
    * Literal matches with any **non-special** characters
    * Any **single character** except \n with `.`
    * Any **number (including 0)** with `*`
    * **Optional** (0 or 1) wit `?`

2. Special characters

    Pattern |                             Matches
    ------- | ---------------------------------------------------------------
    `\d`    | a single **digit**
    `\D`    | a single **non-digit**
    `\w`    | an **alphanumeric** character (alphabets + digits + underscore)
    `\W`    | a **non-alphanumeric** character
    `\s`    | a **whitespace** character
    `\S`    | a **non-whitespace** character
    `\b`    | a **word boundary** (between a \w and a \W, in either order)
    `\B`    | a **non-word boundary**

> The Python _string_ module has predefined string constants that can be used for testing. One of them is _printable_: 100 printable ASCII characters, including letters in both cases, digits, space characters, punctuation. It can be accessed by calling `string.printable()`.

3. Pattern specifiers

      Specifiers    |                          Matches                           
    --------------- | ----------------------------------------------------------
    `abc`           | literal 'abc'                                              
    `(expr)`        | _expr_                                                     
    `expr1 | expr2` | _expr1_ or _expr1_                                         
    `.`             | any character except \n                                    
    `^`             | **start** of source string                                 
    `$`             | **end** of source string                                   
    `prev ?`        | **zero** or one _prev_                                     
    `prev *`        | **zero** or more _prev_, as **many** as possible           
    `prev *?`       | **zero** or more _prev_, as **few** as possible            
    `prev +`        | **one** or more _prev_, as **many** as possible            
    `prev +?`       | **one** or more _prev_, as **few** as possible             
    `prev{m}`       | **_m_ consecutive** _prev_                                 
    `prev{m,n}`     | **_m_ to _n_ consecutive** _prev_, as **many** as possible 
    `prev{m,n}?`    | **_m_ to _n_ consecutive** _prev_, as **few** as possible  
    `[abc]`         | a or b or c (same as a | b | c)
    `[^abc]`        | not (a or b or c)                                          
    `prev(?=next)`  | _prev_ if **followed** by _next_                           
    `prev(?!next)`  | _prev_ if **not followed** by _next_                       
    `(?<=prev)next` | _next_ if **preceded** by _prev_                           
    `(?<!prev)next` | _next_ if **not preceded** by _prev_                       

> Always put an "r" character before regular expression pattern to avoid the conflict with Python's _raw string_. (i.g. `r'\bfish'`)

## 2.3 Patterns: specifying match output

* When using `match()` or `search()`, all matches are returned from the result object _m_ as `m.group()`.
* If you enclose a pattern in parentheses, the match wil be saved to its own group, and a **tuple** of them will be available as `m.groups()`.
* If you use pattern `(?P<name>expr)`, it will match _expr_, saving the match in group _name_.

# 3. Binary data
## 3.1 Bytes and bytearray

* Python 3 introduced the following sequences of **eight-bit integers**, with possible values from 0 to 255, in two types:
    * _bytes_ is **immutable**, like a tuple of bytes
    * _bytearray_ is **mutable**, like a list of bytes

* create:
    * `bytes(_list_)`: create a _byte_ from _list_
    * `bytearray(_list_)`: create a _bytearray_ from _list_

## 3.2 Convert Binary data with struct (a module)

> **struct** is a module which handles data similar to **_structs_** in C and C++.

* `struct.unpack(_method_, _data_)`: Unpack the _data_ using the _method_. (i.g. `width, weight = struct.unpack('>LL', data[16:24])`)
* `struct.pack(_method_, _byte_)`: Pack the _byte_ using the _method_. (i.g. `struct.pack('>L', 154)`)
* Format specifiers for `pack()` and `unpack()`
    1. Endian specifiers

        Specifier |  Byte order
        --------- | -------------
        `<`       | little endian
        `>`       | big endian
    
    2. Format specifiers

        Specifier |        Description         |    Bytes
        --------- | -------------------------- | -----------
        `x`       | skip a byte                | 1
        `b`       | signed byte                | 1
        `B`       | unsigned byte              | 1
        `h`       | signed short integer       | 2
        `H`       | unsigned short integer     | 2
        `i`       | signed integer             | 4
        `I`       | unsigned integer           | 4
        `l`       | signed long integer        | 4
        `L`       | unsigned long integer      | 4
        `Q`       | unsigned long long integer | 8
        `f`       | single precision float     | 4
        `d`       | double precision float     | 8
        `p`       | _count_ and characters     | 1 + _count_
        `s`       | characters                 | _count_

## 3.4 Other binary data tools
There are some useful third-party open source packages:
* [bistring](https://github.com/scott-griffiths/bitstring)
* [construct](https://construct.readthedocs.io/en/latest/)
* [hachoir](https://github.com/vstinner/hachoir)
* [binio](http://spika.net/py/binio/)

## 3.5 Convert Bytes/strings with binascii()
The standard _binascii_ module has functions with which you can convert between binary data and various string representations: hex(base 16), base 64, uuencode, and others.

# Bit operators
Python provides bit-level integer operators, _similar to those in the C language_.

_a_ : decimal 5, binary 0b010 ; _b_ : decimal 1, binary 0b001

Operator | Description  | Example | Decimal result |               Binary result               |
-------- | ------------ | ------- | -------------- | ----------------------------------------- |
`&`      | and          | `a & b` | 1              | 0b0001                                    |
`|`      | or           | `a | b` | 5              | 0b0101                                    |
`^`      | exclusive or | `a ^ b` | 4              | 0b0100                                    |
`~`      | flip bits    | `~a`    | -6             | binary representation depends on int size |
`<<`     | left shift   | `a << 1`| 10             | 0b1010                                    |
`>>`     | right shift  | `a >> 1`| 2              | 0b0010                                    |
