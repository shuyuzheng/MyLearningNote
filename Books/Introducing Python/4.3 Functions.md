---
title: "4.3 Fuctions"
author: Shuyu
date: 30th. Sept. 2018
output:
    word_document:
        path: C:/Users/zsy/Documents/Notes/programming/4.3 Functions.docx
---
# 1. Basic structure
* Function is a named piece of code, separate from all others. 
* A function can take _any number_ and _type_ of input _parameters_ and return _any number_ and _type_ of output _results_.
* You can do two things with a function:
    * Define it:

        ```
        def function_name(_parameters_):
            _operations_
        ```
        * Python requires the _pass_ statement to show that the function does _nothing_

    * Call it:

        ```
        function_name()
        ```

        * The values passed into the function when calling it are known as **arguments**.
        * If a function doesn't call return explicitly, the caller gets the results **None**
            * None is a special Python value that _holds a place_ when there is nothing to say.
            * Distinguishing None:
                ```
                if _thing_ is None:
                    print("It's nothing")
                else:
                    print("It's something")
                ```
            * You'll need None to distinguish a missing value from an _empty value_. Empty objects (strings, sets, ...) are all False but are _not_ equal to None.

# 2. Arguments
## 2.1 Positional arguments

The values of **Positional arguments** are copied to their corresponding parameters *in order*.

## 2.2 Keyword arguments

You can specify arguments by the _names_ of their corresponding parameters, to avoid positional argument confusion.

## 2.3 Specify default parameter values

* You can specify values for parameters. The default is used if the caller does not provide a corresponding argument.
* _Don't_ use a _mutable_ data type as a default argument, so that it will not change when you call it for ore than one times.

## 2.4 Gather positional arguments with "*"

* When used inside the function with a parameter, an asterisk groups a variable number of positional arguments into a _tuple_ of parameter values.
* It is useful for writing functions such as _print()_ that accept a variable number of arguments.
* If your function has required positional arguments as well, _*args_ goes at the _end_ and grabs _all the rest_.

## 2.5 Gather keyword arguments with "**"

```
def function(**kwargs):
    _operations_
```

If you mix positional parameters with *args and **kwargs, they need to occur in that order.

# 3. Docstrings

* You can attach documentation to a function definition by including a string at the _beginning_ of the function body. This is the function's **docstring**.
* To _print_ a function's docstring, call the Python *help()* function. Pass the function's name to get _a listing of arguments_ along with the _docstring_

# 4. Functions are objects in Python

* You can assign them to variables;
* Use them as arguments to other functions;
* Return them from functions.
* Notes: when passing functions as objects, using *function_name* not *function_name()*, otherwise you will _call_ them not _pass_ them.
* You can use functions as elements of _lists_, _tuples_, _sets_, and _dictionaries_. Functions are _immutable_, so you can also use them as dictionary keys.

# 5. Special Types of function
## 5.1 Inner Functions

An **inner function** can be useful when performing some complex task more than once _within_ another function, to avoid loops or code duplication.

```
def outer():
    def inner():
        _operations_
    _operations_

```

## 5.2. Closures
**Closures** is a function that is **dynamically** generated by another functions and can both change and remember the values of variables that were created **outside** the function.

```
def knight2(saying):
    def inner2():
        return "We are the knights who say: '%s'" % saying
    return inner2

a = knight2('Duck')
# Here a is either a function and a closure. It remembers the "saying" you passed to it when you call a()
a()

```

## 5.3 Anonymous Function: the lambda() Functions

In Python, a _lambda function_ is an anonymous function expressed as a single statement. You can use it instead of a normal tiny function. (a little function is defined in a _real function_. It's similar to the inner function() used in "apply" R package.)

```
real_function(_arguments_, lambda _argument_ : _operations_ )
```

# 6.Generators

* A generator is a Python sequence creation object.
* With it, you can iterate through potentially huge sequences without creating and storing the entire sequence in memory at once.
* Every time you iterate through a generator, it keeps track of where it was the last time it was called and returns the next value.
* generator function is a normal function, but it returns its value with a **yield** statement.

```
def my_range(first = 0, last = 10, step = 1):
    number = first
    while number < last:
        yield number
        number += step

# This is a normal function

ranger = my_range(1, 5)

# ranger is a generator function
```

# 7. Decorators

* A _decorator_ is a function that takes one function as input and returns another function. (**modifying an existed _func()_**)
* _Decorators_ can be assign and run manually just as normal functions.
* It can also run by add @decorator_name immediately above the def function.
* When calling more than one decorators, the decorator that's used _closest_ to the function (just above the def) runs _first_ and then the one above.

# 8. Namespaces and Scope

* In Python, each function defines its own namespace.
    * The main part of a program defines the _global namespace_; thus, the variables in that namespace are _global variables_.
        * You can get the value of a global variable from within a function
        * But you **can't get it and then change** it within a function
        * If you try to **change** it, you just get another variable within function with the same name with the global variable.
    * To access the global variable rather than the local one within a function, you need to be explicit and use the **global** keyword.(*global variable_name*)
* Access the contents of namespaces:
    * _locals()_ return a dictionary of the contents of the local namespace.
    * _globals()_ return a dictionary of the contents of the global namespace.

# 9. Uses of _and__ in Namespaces

* Names that begin and end with two underscores(__) are reserved for use within Python. For example, `sum.__doc__` returns the docstring of `sum()`.

# 10. Handle errors 

## 10.1 try and except
* In some languages, errors are indicated by special function **return values**. Python uses **exceptions**(code that is wxecuted when an associated error occurs.)

```
try:
    _function_
except:
    print('messages used to explain error')

```

* The code inside _try block_ is run. If there is an error, an exception is raised and the code inside the _except block_ runs. If there is no errors, the _except block is skipped.
* If more than one type of exception could occur, it's best to provide a **separate exception handler** for each.
* You can use `except _exceptiontype_ as _name_` to get the full exception object in the variable _name_.

## 10.2 Define your own exception

* An exception is a child class of then class Exception.
```
class exception_name(Exception): 
    _operations_

```
