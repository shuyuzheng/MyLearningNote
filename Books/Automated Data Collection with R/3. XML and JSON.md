# 1. XML 

## 1.1. Introduction of XML 

* XML, the e**X**tensible **M**arkup **L**anguage. It is data wrapped in **user-defined** tags.
* Difference between XML and HTML:
    * HTML is used to **shape** the display of information.
    * XML is mainly used to **store** data.
* Advantages of XML:
    * **Plain text**: It makes XML **compatible** because no decoder is needed to interpret them.
    * **self-describing**: The tags could fully describe the document.
    * **nested tags**: It allows XML to be used on representing complex data structures.
* Drawbacks of XML:
    * Lack of efficiency.
    * Redundant information: space cost
    * Weakly to handle large data or highly hierarchical structure.

## 1.2 XML syntax rules
### 1.2.1 Element and attributes
1. Declaration for XML (always lays in the first line)
    * **version**: describes the version of XML syntax
    * **encoding**(optional): the character encoding of the document.
    * **standalone**(optional): _yes_/_no_. indicates whether there are external markup declarations and may affect the content of the document.
    * Example:
    `<?xml version="1.0" encoding="ISO-8859-1"?>`
2. Root element: An XML file must contain **one and only one** root element that embraces the whole document. 
    ```
    <doc_nam>
    ...
    <\doc.name>
    ```

3. **Element syntax**
    * **start**: start tag.
    * **end**: 
        * end tag: `<title>Dr. No<title/>`
        * simply a `/` within the stat tag to generate an **empty** element: `<actors bond="Sean Connery" villain="Joseph Wiseman"/>`
    * It can contain:
        * **other elements**
        * **attributes**: They are slot like elements for information, but **cannot** contain further elements or attributes. Form of attributes: `attribute_name='attribute_value'`
        * **data** of any form and length. (text, numbers or symbols.)
        * **a mixture of everything**
        * **nothing**

## 1.2.2 XML structure
* The structure of XML is **hierarchical**.
* It is **strictly nested**, no cross-nesting is allowed.
* words used to describe nodes: _parent_, _child_, _grandchild_, _siblings_.

## 1.2.3 Naming and special characters 
1. Rules of naming **just like R**:
    * Element names can be composed of
        * letters
        * numbers
        * other characters
        * Special characters are allows, but _not_ recommended.
    * Names must **not start** with:
        * a number
        * a punctuation character
        * the letters xml, XML, or Xml, etc
    * Element names and attribute names are **case sensitive**
    * Names must **not contain** spaces.
2. Predefined entities in XML (all of them are here)

    Character | Entity reference |      Description
    --------- | ---------------- | ---------------------
    `<`       | `&lt;`           | Less than
    `>`       | `&gt;`           | Greater than
    `&`       | `&amp;`          | Ampersand
    `"`       | `&quot;`         | Double quotation mark
    `'`       | `&apos;`         | Single quotation mark

## 1.2.4 Comments and character data
* **Comment**: `<!-- an arbitrary comment -->`. It can be used between tags or within element content, but **not** within element or attribute names.
* **CDATA**: `<![CDATA[1 < 3 < pi < 9]]>`. The Special characters within it will not be interpreted. It means escape sequence can be casted in this environment. CDATA is also apart of the document, which makes it different from comments.

## 1.2.5 XML syntax summary
1. An XML document must have a root element.
2. All elements must have a start tag and be closed, except for the declaration, which is not part of the actual XML document.
3. XML elements must be properly nested.
4. XML attribute values must be quoted.
5. Tags are named with characters and numbers, but may not start with a number or "xml"
6. Tag names may not contain spaces and are case sensitive.
7. Space characters are preserved.
8. Some characters are illegal and have to be replaced by meta characters.
9. Comments can be included as: `<!-- comment -->`
10. Content can be excluded from parsing using: `<![CDATA[...]]>`

* The [XML validator](https://www.xmlvalidation.com/) provided validation for XML files.

# 1.3 Document Type Definitions (DTD)
* A DTD is a set of declarations that defines
    * the XML structure
    * how elements are named
    * what kind of data thy should contain
* The contents of DTD is wrapped in a DOCTYPE definition: `<!DOCTYPE all_contents_here>`
* **XML schema languages**: The languages help to describe and constrain the structure and content of an XML document. It includes DTD and XML Schema(XSD)

# 1.4 XML extensions and technologies
## 1.4.1 Namespaces

* Namespaces are used to **add unique identifier** to make ambiguous names (of elements or attributes) uniquely identifiable.

* The rules for namespace:
    1. Namespaces can be declared in the _root element_ or in the _start tag_ of any other element.
    2. The namespace name does not necessarily have to be a working URL, but it is common practice to use URLs because:
        * They are long, unique string for characters and unlikely duplicate.
        * Actual URLs can point the human reader to pages where more information about the namespace is given.
        * **Prefixes** do _not_ have to be explicitly stated. If they are not explicit the default namespace will be used.

## 1.4.2. Extensions of XML
* The **logic** behind:many data exchange processes can be **standardized** because sender and recipient agree on the content and structure of the data to be exchanged.
* By combining the classical XML features of openness with the benefits of standardization, various XML extensions are developed. 
* A list about XML extension can be found on [wiki](https://en.wikipedia.org/wiki/List_of_XML_markup_languages)

## 1.4.3. Example: Really Simple Syndication (RSS)
* The basic idea is that the information senders convert their content into a **standardized** format that can be **syndicated** to any user.
1. Supplier: information $\rightarrow$ store on web server $\rightarrow$ standardization of content in **RSS channel** (wrapped full or summarized content, metadata)  
2. User: subscript feeds (channel) $\rightarrow$ RSS reader $\rightarrow$ manage subscriptions, parse feeds, display contents

* structure of RSS:
    1. XML and RSS declaration in the _first two lines_.
    2. `<channel>` element wraps around
        * **meta block**: 
            * required: `<title>, <description>, <link>`
            * optional: `<lastBuildDate>`
        * **content block**: a set of `<item>`
            * `<title>`
            * `<description>`: main content
            * `<link>`
## 1.4.4. Example: scalable vector graphics (SVG)
* **Vector graphic format** consist of basic **geometric form** which can be expressed mathematically, such as points, curves, circles, lines, or polygons...
* **Raster graphic formats** store graphic information as a raster of pixels that is rectangular cells of a certain color.
* Ordinary can edit SVG but SVG editors could be more convenient. **Inkspace** is a commonly used, open-source graphic editor.

* structures of SVG:
    * XML declaration in the first line.
    * a set of predefined elements and attributes:
        * `<line>`: Lines
        * `<rect>`: rectangles
        * `<circle>`: circles
        * `<ellipse>`: ellipses
        * `<polygon>`: polygons
        * `<text>`: text
        * `<path>`: paths
    * elements can be thought as layers: later-listed element covers the previous ones.

* By default, elements come in the compact form of XML element syntax: Elements are usually **empty** and contain no further information than those given in the attributes.

* Advantages of SVG:
    * can be edited with any text editor
    * opened with the common browsers (different from other XML)
    * follows a familiar syntax as it is basically just XML

* SVG for data collection:
    * It is stared in **text form** and can therefore be searched, subsetted, etc.
    * It is widely used to store geographic information, create interface maps, or visualize massive amounts of data.

## 1.5 XML and R in practice
### 1.5.1 Parsing XML
* Basic steps:
    1. the symbol sequence that constitutes the XML file is read in and used to build a hierarchical tree-like data structure from its elements in the C language.
    2. this data structure is translated into an R data structure via the use of handlers.
* `xmlParse()`: 
    * `asText`: treat the input as XML and not as a file name.
    * `fullNamespaceInfo`: to decide whether both namespace URL and prefic should be provided on each node or just the prefix.
    * `isSchema`: to determine whether an XML schema is parsed.
    * `validate`: to validate the XML against a DTD. But in most web scraping scenarios, there is **no need** to validate the files.
* Other parsers: `xmlTreeParse()`, `xmlInternalTreeParse()`, `xmlNativeTreeParse()`, `and xmlEventParse()`

### 1.5.2 Basic operations on XML documents
* `xmlRoot()`: extract the **top-level** node.
* `xmlName()`: return the element's name.
* `xmlSize()`: return the element's number of children.
* Within the node sets, basic **navigation and subsetting** works just like indexing ordinary R lists. Using `[]` for `XMLInternalDocument`, and '[[]]`for others.

### 1.5.3 From XML to data frames or lists 
THe XML package provides some basic functions. They are just listed here, but we usually don't use them.

* `xmlSApply()`: extract information by combining with some other functions,such as `xmlValue()` or `xmlGetAttr()`, and get a single vector.
* `xmlToDataFrame()`: it works when the XML documents are **flat** in the hierarchical sense.
* `xmlTolist()`

### 1.5.5 Event-driven parsing
* **event-driven** parsing is differ from DOM-style parsing. It **skip** the construction of the complete DOM at the C level. 
* It sequentially **traverse over** an XML file, and once thy find a specified element of interest they prompt an instant, **user-defined** reaction to the event.

* Steps:
    1. Definite handler functions
    2. Using `xmlEventParse()` to execute the handler

# JSON (**J**ava**S**cript **O**bject **N**otation)
It is much similar with **dictionary in Python**, but has order?
## 2.1 structure of JSON
* Brackets:
    * Curly brackets, `{}`, embrace objects. It can contain collection of **comma separated "key":"value" pairs**, other objects, or arrays. 
    * Square brackets, `[]`, enclose arrays. An array is an **ordered sequence** of **comma separated** objects or values.(list in Python)
* data types in JSON:
    * number
    * string
    * boolean
    * null
    * objects
    * array
* It is **not** a markup language or even a document format. It is a **data interchange standard**
* [JSON Format and Validator](https://jsonformatter.curiousconcept.com/) could be used to facilitate accessing JSON documents for human readers.
* [freeformatter](https://www.freeformatter.com/): convert XML to JSON data.

* Advantages:
    * It is more **lightweight** than XML
    * It is used to generate **dynamic content** and **user-browser interactions**
    * It is **compatible** with JavaScript and can be directly parsed into JavaScript objects.

# 2.2 JSON and R in practice
* R PACAGES FOR json: 'rjson', 'RJSONIO', 'jsonlite'
* RJSONIO:
    * `fromJSON()`: reads content in JSON format and converts it to R objects.
    * `toJSON()`: reads R objects and converts it to JSON format.
* To convert hierarchical documents (XML, JSON, R list) into R dataframe, You should decide which elements do you need. There are two strategies:
    1. **flattens** the complex list structure into one vector. Then extract the elements by "name"
        * drawback: all list elements are coerced to a common mode, resulting in character vectors in most cases.
        * When many variables have to be extracted, this step-by-step approach is tedious.
    2. use `sapply()` and feeds it with the `[[` operators and the variable name for element subsetting. (e.g. `sapply(list[[1]], "[[", "year")`)
    3. pull all variables and directly assemble them into a data frame. (some variables do not exist in some data frames.)
        ```
        library(plyr)
        indy.unlist <- sapply(indy[[1]], unlist)
        indy <- do.call("rbind.fill", lapply(lapply(indy.unlist, t), data.frame, stringsAsFactors = FALSE))
        ```
    
